---
layout: article
---

### History

At the early stage of forming C++, templates were proposed by SGI company and added as a very powerful tool to create generic code. Templates originated from Ada generics. Later, there have been multiple (often accidental) discoveries: C++ templates syntax is a standalone, turing-complete, purely functional language. As the time progressed, more features regarding templates have been added (such as alias templates, variable templates, and fold expressions).

Today templates are the thing that makes C++ to be C++. Almost every class and function in C++ standard library is a template. The most similar other language which supports metaprogramming is [Haskell](https://en.wikipedia.org/wiki/Haskell_(programming_language)), but it differs from C++ that it is resolved at runtime. In short, C++ offers Haskell capabilities to be parsed and executed at compile time and merged with non-template source code. 

Generic code offers high portability, extensibility and offers a very large code reuse. Corner cases can be handled by template specializations and other forms of static polymorphism.

[SO question](https://stackoverflow.com/questions/1039853/why-is-the-c-stl-is-so-heavily-based-on-templates-and-not-on-interfaces) regarding history and why templates were chosen over OO design for C++ standard library.

#### Question: Are templates hard to learn?

It depends what do you mean by "hard". If you mean "taking a lof of time" that's not a good definition - by "hard" I would mean "difficult to grasp, high entry level and complex rules". This guide is made to allow incremental step-by-step learning - there is no steep curve. Anyone with average understanding of C++ should be able to go through. If you follow lessons and not forget core things between them there should be no problems. Still, if you find something ~~hard~~ difficult to understand, send me a message on Reddit or open an issue on GitHub.

#### Question: Are C++ templates similar to dynamically typed languages?

Sort of. Templates allow duck typing, but the difference is that in dynamically typed languages runtime convertions are used. In C++ everything is resolved at compile time, so in case of problems instead of getting a runtime exception you get a compilation error. Templates allow much stricter aliasing rules and each use can and usually will generate a very different machine code - this is different from dynamic typing which embeds type info into objects and uses one function implementation which queries the type metadata at runtime and changes execution path depending on it. C++ templates do not contribute to the executable code if they are not used.

#### Question: I have an experience in Java/C# generics. Will it help me?

Yes. Generics in Java and C# share a common set of features also available in C++. The syntax is very similar, the core difference is that instead of forming boxing/unboxing interface implementations C++ templates are transformed into direct machine code which is optimized for exact use case. This allows templates to support much more advanced features (unavailable in Java and C#) such as creating objects of type `T`, expressions like `t1 + t2` or accessing `t.foo` even if aliased type is unknown.

#### Question: Why template compiler erors are so complex?

This is mostly due to how they work. This is not syntax or non-template language error, but a complete metaprogram which is executed before compilation stage. Currently the best what a compiler can offer is printing the whole stack and reason why it had to stop - similar to a runtime exception.

However, concepts from C++20 are vastly shortening and simplyfing many errors. They constrain templates for certain "concepts" and perform checks ahead. In case of errors instantiating ends much sooner with a cleaner message there is no point to continue becase a concept was not satisfied.

#### Question: Can I see the non-template C++ code generated by the use of templates?

Only the machine code. There is no visible mid-step stage at which you could see and read it. Template instantiations are transformed into machine code directly, with no text files generated in between.

However, there are some ways you could achieve it - there are some LLVM based tools, which could do that (I heard they even have template metaprogram debugger). Lastly you can always copy-paste template code and it's relevant specializations and just find-replace each `T` to the type you want.

#### Tool support

Templates are ~~hard~~ complex to parse. This usually results in lower support from various editors. In many cases, autocomplete will not work because it is not know what `T` is or has.

Eclipse has relatively good code parser and smart autocomplete, but it does not parse well all features (yet). At the time of this writing, supported is C++14/17 with the exception of variable templates (code may be wronly underlined as invalid syntax etc) and C++17 language features like structured bindings or static ifs. I'm not sure but similar things may also happen in Visual Studio (likely older versions). Qt Creator is good at this place because it will not complain about syntax it can not understand - just won't display suggestions. It loses syntax highlightingin such places though.

If you find an IDE to be wrong, or to not support newer or more advanced features and annoying you with false errors I recommend to switch to text editors sush as Notepad++, Atom and Visual Studio Code. Or Qt Creator.

#### Fun fact

Because C++ templates are Turing-complete, this means they form a standalone programming language and there is no easy way to predict the result. It's a sort of [halting problem](https://en.wikipedia.org/wiki/Halting_problem) - compiler can not dedice whether metaprogram will or will not finish. The only way to know it is to execute it. **It's possible to write a C++ code that has infinitely long compile time.** In later chapters I will post various examples and explain how to grasp the full power of template metaprogramming.

#### Code structure

Because C++ templates form a metaprogram that is executed at compile time, their complete definitions must be available at the moment of instantiation. This means that you need to put full definitions of templates before they get used in evaluating contexts. That's why templates are put in header files. Technically you can put them in source files, but as with classes they will be only available in that source file.

Templates, like functions and classes have a declaration and definiton part. Almost always entire definitions are written instantly, because both declaration and definition would need to be visible anyway. The only reason where you would need to split and write declaration separately are rare cases in CRTP which are explained in relevant article.

`template` and `constexpr` imply `inline` so you don't have to add it manually. Eclipse places it unnecessarily.

**tl;dr Put complete template definitions in header files because that's how they work.**
